**File:** `move-indiamed-api\APIAccessManagementMigration\src\com\tcl\api\model\CustomerData.java`

---

## 1. High‑Level Summary
`CustomerData` is a plain‑old‑Java‑object (POJO) that represents the core customer payload exchanged during the **API Access Management Migration** workflow. It carries the customer reference, account identifier, billing entity, currency, and a list of `CustomProduct` objects (defined in the same model package). The class is used for JSON/XML (de)serialization between the migration service, downstream billing/CRM systems, and any intermediate message queues.

---

## 2. Important Classes & Their Responsibilities  

| Class / Method | Responsibility |
|----------------|----------------|
| **`CustomerData`** (public) | Container for customer‑level attributes required by the migration API. |
| `String getCustomerRef()` / `setCustomerRef(String)` | Accessor for the external customer reference (e.g., CRM key). |
| `String getAccountNumber()` / `setAccountNumber(String)` | Accessor for the account number used by the billing system. |
| `String getBillingEntity()` / `setBillingEntity(String)` | Accessor for the legal billing entity (e.g., “TCL India”). |
| `String getCurrency()` / `setCurrency(String)` | Accessor for the ISO‑currency code of the account. |
| `List<CustomProduct> getProductNames()` / `setProductNames(List<CustomProduct>)` | Accessor for the collection of products/services attached to the customer. |

*Note:* All other model classes listed in the **HISTORY** (e.g., `AccountDetail`, `Address`, `CustomProductAttribute`) are siblings in the same package and are typically nested inside or referenced by `CustomerData` during request/response mapping.

---

## 3. Inputs, Outputs, Side Effects & Assumptions  

| Aspect | Details |
|--------|---------|
| **Input** | Instances of `CustomerData` are populated from upstream sources: <br>• REST API payloads (JSON) <br>• Database extracts (via ORM or JDBC) <br>• Message queue events (e.g., Kafka, MQ) |
| **Output** | Serialized form (JSON/XML) sent to downstream systems: <br>• Billing engine <br>• CRM enrichment service <br>• Audit/logging subsystem |
| **Side Effects** | None – the class itself is immutable in behavior; side effects arise only from callers that persist or transmit the object. |
| **Assumptions** | • All fields may be `null` unless validated upstream. <br>• `CustomProduct` list is non‑null when a customer has at least one product; otherwise it may be empty. <br>• The class is used with a Jackson/Gson mapper that respects standard JavaBean getters/setters. |

---

## 4. Integration Points (How This File Connects to Other Scripts/Components)

| Connected Component | Interaction |
|---------------------|-------------|
| **`CustomProduct`** (same package) | `CustomerData.productNames` holds the list; migration logic iterates this list to build product‑level requests. |
| **API Controllers / Service Layer** (`com.tcl.api.service.*`) | Controllers deserialize incoming JSON into `CustomerData`; services transform it into internal domain objects or outbound DTOs. |
| **Message Queues** (e.g., `customer-migration-topic`) | `CustomerData` objects are marshalled to JSON and published; consumer services reconstruct the POJO for further processing. |
| **Database Access Layer** (`CustomerDao`, `AccountDao`) | DAO methods map result‑sets to `CustomerData` for batch migration jobs. |
| **Logging / Auditing** (`AuditLogger`) | The object may be logged (via `toString()` generated by IDE) for traceability; no explicit `toString` is defined, so default `Object.toString` is used unless overridden elsewhere. |
| **Configuration** | No direct config references; however, serialization features (date format, naming strategy) are driven by external `application.yml`/`properties` used by the Jackson mapper. |

---

## 5. Operational Risks & Recommended Mitigations  

| Risk | Impact | Mitigation |
|------|--------|------------|
| **Null / Missing Fields** | Downstream validation failures or NPEs in processing code that assumes non‑null values. | Enforce validation in the service layer (e.g., Bean Validation `@NotNull` annotations) before persisting or transmitting. |
| **Schema Drift** | Changes to `CustomProduct` or addition of new fields may break serialization if not versioned. | Use explicit versioned DTOs or maintain backward‑compatible JSON mapping (e.g., `@JsonIgnoreProperties(ignoreUnknown = true)`). |
| **Large Product List** | Excessive payload size leading to network timeouts or queue back‑pressure. | Implement pagination or streaming for bulk product transfers; enforce a reasonable max size in validation. |
| **Lack of `equals/hashCode` / `toString`** | Difficulty in debugging duplicate detection or logging. | Generate Lombok `@Data` or manually implement these methods. |
| **Thread‑Safety Misconception** | Shared mutable instances could be modified concurrently. | Treat `CustomerData` as immutable after construction; avoid sharing mutable references across threads. |

---

## 6. Example: Running / Debugging the POJO  

1. **Unit Test Instantiation**  
   ```java
   @Test
   public void testCustomerDataSerialization() throws Exception {
       CustomerData cd = new CustomerData();
       cd.setCustomerRef("CUST12345");
       cd.setAccountNumber("ACC98765");
       cd.setBillingEntity("TCL India");
       cd.setCurrency("INR");
       cd.setProductNames(Arrays.asList(
           new CustomProduct("ProdA", "2023-01-01"),
           new CustomProduct("ProdB", "2023-02-15")
       ));

       ObjectMapper mapper = new ObjectMapper();
       String json = mapper.writeValueAsString(cd);
       System.out.println(json); // verify structure
   }
   ```

2. **Debugging in a Service**  
   - Set a breakpoint on any setter or on the controller method that receives the request.  
   - Inspect the populated `CustomerData` instance; verify that `productNames` is not `null` and contains expected `CustomProduct` entries.  
   - Use the IDE’s “Evaluate Expression” to call `mapper.writeValueAsString(customerData)` and compare with the inbound payload.

3. **Running the Migration Job**  
   - The job is typically launched via a Spring Boot `CommandLineRunner` or a scheduled Quartz job.  
   - Ensure the classpath includes `move-indiamed-api/.../model` so the mapper can locate `CustomerData`.  
   - Monitor logs for any `JsonMappingException` indicating mismatched field names.

---

## 7. External Configuration / Environment Variables  

| Config / Env | Usage |
|--------------|-------|
| **Jackson Mapper Settings** (`spring.jackson.*` in `application.yml`) | Controls property naming strategy, date format, and inclusion rules for serializing `CustomerData`. |
| **Message Queue Topics** (`CUSTOMER_MIGRATION_TOPIC`) | Not referenced directly in this file but required by the producer that sends the serialized POJO. |
| **Feature Flags** (`migration.enableCustomerData`) | May be consulted by the service layer to decide whether to process `CustomerData` objects. |

No hard‑coded values or environment look‑ups exist inside `CustomerData.java` itself.

---

## 8. Suggested TODO / Improvements  

1. **Add Bean Validation Annotations**  
   ```java
   @NotBlank private String customerRef;
   @NotBlank private String accountNumber;
   @NotBlank private String billingEntity;
   @Pattern(regexp = "^[A-Z]{3}$") private String currency;
   @NotEmpty private List<CustomProduct> productNames;
   ```
   This enforces data integrity early in the pipeline.

2. **Replace Boilerplate Getters/Setters with Lombok**  
   ```java
   @Data @NoArgsConstructor @AllArgsConstructor
   public class CustomerData { ... }
   ```
   Reduces maintenance overhead and automatically provides `equals`, `hashCode`, and `toString`.

---