**File:** `move-indiamed-api\APIAccessManagementMigration\src\com\tcl\api\callout\APICallout.java`

---

## 1. High‑Level Summary
`APICallout` is the orchestration driver for the *API Access Management Migration* job. It reads raw EID records from the staging table (via `RawDataAccess`), determines the required business action (NEW, CHANGE, TERMINATE), enriches each record with account numbers, custom‑plan and product attributes (through helper call‑out classes), updates the target tables, and finally posts order details to downstream systems. The class is invoked from the command line (or a wrapper script) with a single argument – the path to a file that stores already‑processed input‑group‑IDs – and terminates the JVM with an explicit exit code.

---

## 2. Core Classes & Functions  

| Class / Method | Responsibility |
|----------------|----------------|
| **APICallout** (public) | Main orchestration class; holds DAO and helper objects, static caches, and the `callOut(String)` entry point. |
| `callOut(String inputGroupIdFile)` | Entry point called by the job runner. Executes the **NEW** scenario (`newStatusAPI`) then the **TERMINATE** scenario (`statusAPI`). Handles any uncaught exception and forces `System.exit`. |
| `newStatusAPI(String inputGroupIdFile)` | Handles **NEW** records: fetches raw data, resolves account numbers, caches product attributes, performs bulk inserts/updates, and finally posts order details for any new input‑group‑IDs. |
| `statusAPI(StatusEnum status, String inputGroupIdFile)` | Handles **CHANGE** and **TERMINATE** records (currently invoked with `TERMINATE`). Retrieves raw data, checks current DB status, obtains a sequence number, reads the associated input‑group‑ID and posts order details. |
| `newStatusChangeAPI(EIDRawData eid)` | Executes the full change‑plan flow for a single EID: fetches account number, updates custom‑plan, product attributes, address, and inserts the change‑account‑number record. |
| `convertMapToEntity(...)` | Utility that builds an `EIDRawData` DTO from a raw map of column values. |
| `getRawDataAccess(StatusEnum)` | Wrapper around `RawDataAccess.fetchEIDRawData` – returns a list of `EIDRawData` for the supplied status. |
| `getAcntNum(String secsid)` / `getAcntNum(String secsid, String accountType)` | DAO calls that retrieve the account number for a given secondary ID (optionally filtered by account type). |
| `getCustomPlanDetail(EIDRawData, String)` | Calls `CustomPlanDetails.getCustomPlanDetails` to obtain custom‑plan key/value pairs. |
| `getProductDetails(EIDRawData, String)` | Calls `ProductDetails.getProductDetails`; results are cached in `outerHashMap` keyed by `PLAN_TYPE_ACCOUNT`. |
| `getpostOrderDetails(List<PostOrderDetail>, String)` | Delegates to `PostOrder.postOrderDetails` to write order files / send downstream messages. |
| `getStackTrace(Exception)` | Helper that converts an exception stack trace to a string for logging. |
| **Helper objects** (instantiated once) | `AccountNumDetails an`, `CustomPlanDetails cpd`, `ProductDetails pds`, `RawDataAccess rda`, `PostOrder po`. Each encapsulates a specific external API or DAO call. |

*Other private methods (`changePlanStatusAPI`, `callNewChangePlan*`, `sameDayScenario`, etc.) are stubs or unused in the current production flow.*

---

## 3. Inputs, Outputs & Side Effects  

| Aspect | Details |
|--------|---------|
| **Input argument** | `inputGroupIdFile` – path to a plain‑text file containing previously processed input‑group‑IDs (one per line). |
| **External services / APIs** | - **Database** via `RawDataAccess` (reads raw EID data, sequence numbers, account numbers, performs bulk inserts/updates). <br> - **Account Number Service** (`AccountNumDetails.getAccountNumDetails`). <br> - **Custom Plan Service** (`CustomPlanDetails.getCustomPlanDetails`). <br> - **Product Attribute Service** (`ProductDetails.getProductDetails`). <br> - **Post‑Order Service** (`PostOrder.postOrderDetails`). |
| **Outputs** | - Updated rows in several target tables (account number, custom plan, product attributes, address). <br> - Order files / downstream messages generated by `PostOrder`. <br> - Updated `inputGroupIdFile` (the file is read but not written; downstream `PostOrder` may append). |
| **Side effects** | - Calls `System.exit(0)` on normal completion and `System.exit(1)` on any error, terminating the JVM. <br> - Logs extensively via Log4j (configured by `log4j.properties`). |
| **Assumptions** | - All DAO SQL statements are correctly defined in `APIAccessDAO.properties`. <br> - The helper classes (`AccountNumDetails`, `CustomPlanDetails`, `ProductDetails`, `PostOrder`) are functional and reachable on the classpath. <br> - The input‑group‑ID file exists and is readable. <br> - The database schema matches the DTO fields (`EIDRawData`). <br> - No concurrent execution of the same job (because of static caches and `System.exit`). |

---

## 4. Integration Points  

| Component | Connection Detail |
|-----------|-------------------|
| **RawDataAccess** (`com.tcl.api.dao.RawDataAccess`) | Provides all DB reads/writes; its SQL statements are stored in `APIAccessDAO.properties`. |
| **AccountNumDetails** (`com.tcl.api.callout.AccountNumDetails`) | External API (likely a REST or SOAP service) that resolves a secondary ID to an account number. |
| **CustomPlanDetails** (`com.tcl.api.callout.CustomPlanDetails`) | API that returns custom‑plan attributes for a given EID/account. |
| **ProductDetails** (`com.tcl.api.callout.ProductDetails`) | API that returns product attribute map; results are cached in `outerHashMap`. |
| **PostOrder** (`com.tcl.api.model.PostOrder`) | Generates order files or pushes messages downstream; consumes the list of `PostOrderDetail` objects built from DB data. |
| **StatusEnum** (`com.tcl.api.constants.StatusEnum`) | Enum used to drive the flow (`NEW`, `TERMINATE`, etc.). |
| **Log4j** | Logging configuration is external (`log4j.properties`). |
| **Input‑Group‑ID file** | Shared with other scripts that may also read/write the same file to avoid duplicate order processing. |

---

## 5. Operational Risks & Mitigations  

| Risk | Impact | Mitigation |
|------|--------|------------|
| **Abrupt JVM termination** (`System.exit`) | Stops the entire Java process; if the job runs inside a container or scheduler, it may be marked as failed and retried, potentially causing duplicate processing. | Replace `System.exit` with proper exception propagation; let the scheduler handle exit codes. |
| **Uncaught exceptions in helper APIs** | Any failure in account‑number, custom‑plan, or product APIs leads to immediate termination, possibly leaving partial updates. | Implement retry logic and circuit‑breaker patterns; log the failing EID and continue with next record where safe. |
| **Static caches (`outerHashMap`) not cleared** | In long‑running JVMs, memory may grow if many distinct `PLAN_TYPE_ACCOUNT` keys are processed. | Add cache eviction (e.g., LRU) or clear the map after each batch. |
| **Hard‑coded exit on missing account number** (`break` inside loop) | Stops processing of the entire batch when a single account number cannot be resolved. | Record the failure, continue with remaining EIDs, and generate a reconciliation report. |
| **File‑based deduplication (`inputGroupIdFile`)** | If the file becomes out‑of‑sync, duplicate orders may be generated. | Use a database‑backed lock table or atomic file writes; rotate the file periodically. |
| **Bulk operations without transaction boundaries** | `bulkInsertAccountNumbers`, `bulkUpdateProductattr`, etc., may partially succeed, leaving inconsistent state. | Wrap bulk DB calls in a single transaction where possible; verify row counts after each operation. |

---

## 6. Running / Debugging the Script  

1. **Build** – Ensure the project is compiled (`mvn clean package` or equivalent) and all dependent JARs (DAO, helper APIs) are on the classpath.  
2. **Configuration** – Verify that:  
   * `log4j.properties` is on the classpath (controls logging).  
   * `APIAccessDAO.properties` is accessible (contains SQL statements).  
   * Any environment variables required by the helper APIs (e.g., endpoint URLs, auth tokens) are set.  
3. **Execution** – From the command line (or a wrapper script):  

   ```bash
   java -cp <classpath> com.tcl.api.callout.APICallout <path-to-inputGroupIdFile>
   ```

   The program will log progress to the configured Log4j appenders and exit with code 0 on success, 1 on error.  

4. **Debugging** –  
   * Increase Log4j log level to `DEBUG` to see detailed flow.  
   * Attach a remote debugger (e.g., `-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5005`) before invoking `callOut`.  
   * Inspect the static `outerHashMap` to verify caching behavior.  
   * After a failure, check the generated stack‑trace in the logs; the `getStackTrace` helper prints the full exception chain.  

5. **Unit / Integration Tests** – Create mock implementations of `RawDataAccess`, `AccountNumDetails`, etc., to exercise each branch (NEW, TERMINATE) without touching production systems.

---

## 7. External Configuration & Environment Dependencies  

| Item | Usage |
|------|-------|
| `log4j.properties` | Controls logging output (levels, appenders, file locations). |
| `APIAccessDAO.properties` | Supplies all SQL statements used by `RawDataAccess` (SELECT, INSERT, UPDATE, bulk operations). |
| Environment variables (e.g., `API_ENDPOINT`, `API_AUTH_TOKEN`) | Expected by the helper classes (`AccountNumDetails`, `CustomPlanDetails`, `ProductDetails`) to reach external services. |
| Java system properties (e.g., `-Dlog4j.configuration`) | May be used to point to an alternative logging config. |
| Input‑group‑ID file path (argument) | Must be readable/writable by the process; shared with other jobs for deduplication. |

---

## 8. Suggested Improvements (TODO)

1. **Replace `System.exit` with proper exception handling** – Allow the scheduler to capture exit codes and avoid killing the JVM abruptly; return status via a custom result object or exit code only at the outermost wrapper.  
2. **Introduce a transaction manager for bulk DB updates** – Wrap the series of bulk inserts/updates (`bulkInsertAccountNumbers`, `bulkUpdateProductattr`, etc.) in a single database transaction to guarantee atomicity and simplify rollback on failure.  

---